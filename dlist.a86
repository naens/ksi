;; Program: dlist
;; Lists files of directory with sizes

array_maxlen	equ	100h
filename_size	equ	11

;;====
;;
;; Function: main
;;
;;     Displays the contents of the directory provided as argument.
;;     If no argument provided, displays the contents of the current
;;     directory.  Also displays the sizes of each file.  The list of
;;     files is sorted by the name of the file.  The filenames are
;;     displayed in /name-dot-extension/ format or just the name
;;     if the file has no extension.
;;
;; Parameters:
;;
;;     command line arguments - the directory and the filename.  Both are
;;     optional.  The filename can be ambiguous (containing ? and/or *).
;;     The default directory is the current and the default filename
;;     matches any file.
;;
;; Returns:
;;
;;     nothing
;;
;; Side Effects:
;;
;;     Prints the list of filenames on the default console.
;;
;;====
;
; Pseudocode:
;
;     if no arguments, match any file
;     copy filenames to array in /name-dot-extension/ format.
;     sort filenames in the array alphabetically
;     display filenames and sizes
;

	dseg
	org	5ch
fcb	rb	36		; the fcb for f_sfirst and f_snext

	org	80h
dma_buf	rb	80h		; dma buffer to read filenames from

	org 100h

	cseg
	; TODO: main function

;;====
;;
;; Function: rdfn
;;
;;     Reads the file names using *f_sfirst* and *f_snext* system calls
;;     copies them into the array.  The filenames are null-terminated
;;     strings.
;;
;; Parameters:
;;
;;     ax - The address of the array for the pointers to the filenames.
;;
;; Returns:
;;
;;     ax - The number of filenames in the array.
;;
;; Side Effects:
;;
;;     The array contains the addresses of filenames.
;;
;; Modified Registers:
;;
;;     si, di, ax, bx, cx
;;
;;====
;
; Private Variables:
;
;     aa - address of the array
;     buf - string buffer, used for containing filenames.
;              Its size is 12 times maximum amount of file names.
;     buflen - current length of the buffer
;     alen - current length of the array
;     slen - length of the current string
;
; Pseudocode:
;
;     // initialize
;     alen := 0
;     buflen := 0
;
;     // get the first filename
;     call f_sfirst
;     if no file then
;         return 0
;
;     // get the rest of the filenames
;     loop:
;
;         // copy filename to array
;         length := fn_conv(&fcb, &array[alen])
;
;         // update array and array length variables
;         array[alen] := offset buf + buflen
;         alen := alen + 1
;
;         // update buffer length
;         buflen := buflen + length + 1
;
;         // test if enough space in the array
;         if alen = array_maxlen, then
;             return array_maxlen
;
;         // get the next file name
;         call f_snext
;         if no file then
;             break loop
;
;         // continue
;         continue loop
;
;     return alen
;
	dseg $
rdfn@aa		rw	1
rdfn@alen	rw	1
rdfn@buf	db    array_maxlen * (filename_size + 1)
rdfn@buflen	rw	1
rdfn@slen	rw	1

	cseg $
	; initialize
	mov	rdfn@aa, ax
	mov	rdfn@alen, 0
	mov	rdfn@buflen, 0

	; get the first filename
	mov	cl, f_sfirst
	mov	dx, offset fcb
	call	ccpm

	; if no file, return 0
	cmp	al, 0ffh
	je	rdfn@end

	; get the rest of the filenames
rdfn@loop:

	; set si to the address of the filename
	; si := offset dma_buf + al * 32 + 1
	mov	si, offset dma_buf
	mov	cl, 5
	shl	al, cl
	add	si, ax
	inc	si

	; set di to the address of the destination
	; di := offset buf + buflen
	mov	di, offset rdfn@buf

	; length := fn_conv(&fcb, &array[alen])
	call	fn_conv	; copy filename to s_next
	mov	rdfn@slen, ax

	; array[alen] := offset buf + buflen
	mov	ax, offset rdfn@buf
	add	ax, rdfn@buflen
	mov	bx, rdfn@alen
	shl	bx, 1
	add	bx, rdfn@aa
	mov	[bx], ax

	; alen := alen + 1
	add	rdfn@alen, 2

	; buflen := buflen + length + 1
	inc	rdfn@buflen

	; test if enough space in the array
	cmp	rdfn@alen, array_maxlen
	jnb	rdfn@end

	; get the next file name
	mov	cl, f_snext
	mov	dx, offset fcb
	call	ccpm

	; if no file, then exit loop
	cmp	al, 0ffh
	je	rdfn@end

	; otherwise, continue loop
	jmp	rdfn@loop

rdfn@end:
	mov	ax, rdfn@array_len
	ret

exit:
	; exit
	mov	cl, p_termcpm
	call	ccpm

;;====
;;
;; Function: fnconv
;;
;;     Converts 11-character filenames to <name><'.'><ext>.
;;     The result is null-terminated.  The length of the
;;     string is returned in ax.
;;
;; Parameters:
;;
;;     si - The address of the source string
;;     di - The address of the destination
;;
;; Returns:
;;
;;    ax - The length of the destination string (without the null-byte)
;;
;; Modified Registers:
;;
;;     si, di, ax, bx, cx
;;
;;====
;
; Register Usage:
;
;     si - pointer to the current character in the source string
;     di - pointer to the current character in the destination string
;     cx - counter
;     bx - saves the initial value of dx
;     ax - used for return of the length of the result string
;
; Pseudocode:
;
; bx = di
; cx = 8
; while cx > 0 do	// @name
;     [di++] = [si++]
;     cx--
;     if [si] == ' ' then
;         break
; end
; si += cx
; if [si] <> ' ' then	// @test_extension
;     cx = 3
;     [di] = '.'
;     di++
;     while cx > 0	// @extension
;         [di++] = [si++]
;         cx--
;         if [si] == ' 'then
;             break
;     end
; [di] = 0		// @end
; return di - bx
;
fnconv:
	; copy the filename
	cld
	mov	cx, 8
	mov	bx, di		; save destination address

	; name loop
fnconv@nl:
	movsb
	dec	cx
	jz	fnconv@test
	cmp	byte ptr [si], ' '
	jne	fnconv@nl

	; adjust si to point to the extension
	add	si, cx

	; test whether there is an extension
fnconv@test:
	cmp	byte ptr [si], ' '
	je	fnconv@end

	; copy the extension
	mov	byte ptr [di], '.'
	inc	di
	mov	cx, 3

	; extension loop
fnconv@el:
	movsb
	dec	cx
	jz	fnconv@e
	cmp	byte ptr [si], ' '
	jne	fnconv@el

fnconv@e:
	; put null byte
	mov	[di], 0

	; return ax = length of the destination string
	sub	di, bx
	mov	ax, di
	ret


;;; External Imports ;;;

include bdos.def
include cons.a86
include str.a86
include sys.a86


end

