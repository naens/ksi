;; Program: DirList
;; Lists files of directory with sizes

array_maxlen	equ	100h
filename_size	equ	11

;;====
;;
;; Function: main
;;
;;     Displays the contents of the directory provided as argument.
;;     If no argument provided, displays the contents of the current
;;     directory.  Also displays the sizes of each file.  The list of
;;     files is sorted by the name of the file.  The filenames are
;;     displayed in /name-dot-extension/ format or just the name
;;     if the file has no extension.
;;
;; Parameters:
;;
;;     command line arguments - the directory and the filename.  Both are
;;     optional.  The filename can be ambiguous (containing ? and/or *).
;;     The default directory is the current and the default filename
;;     matches any file.
;;
;; Returns:
;;
;;     nothing
;;
;; Side Effects:
;;
;;     Prints the list of filenames on the default console.
;;
;;====
;
; Pseudocode:
;
;     if no arguments, match any file
;     copy filenames to array in /name-dot-extension/ format.
;     sort filenames in the array alphabetically
;     for each filename in the array:
;         display filename
;         display size
;         do crlf
;

	dseg
	org	5ch
fcb	rb	36		; the fcb for f_sfirst and f_snext

	org	80h
dma_buf	rb	80h		; dma buffer to read filenames from

	org 100h
a	rw	a_max		; the array of pointers to strings
a_len	dw	0		; the current length of a in words
s	rb	a_max * fn_sz	; the array of null-terminated strings
s_next	rw	offset s	; offset for the next string in s

;;====
;;
;; Function: read_filenames
;;
;;     Reads the file names using *f_sfirst* and *f_snext* system calls
;;     copies them into the array.  The filenames are null-terminated
;;     strings.
;;
;; Parameters:
;;
;;     ax - The address of the array for the pointers to the filenames.
;;
;; Returns:
;;
;;     ax - The number of filenames in the array.
;;
;; Side Effects:
;;
;;     The array contains the addresses of filenames.
;;
;; Modified Registers:
;;
;;     si, di, ax, bx, cx
;;
;;====
;
; Private Variables:
;
;     array_offset - address of the array
;     buffer - array of bytes, used for containing filenames.
;              Its size is 12 times maximum amount of file names.
;     buffer_length - current length of the buffer
;     array_length - current length of the array
;     string_length - length of the current string
;
; Pseudocode:
;
;     // initialize
;     array_length := 0
;     buffer_length := 0
;
;     // get the first filename
;     call f_sfirst
;     if no file then
;         return 0
;
;     // get the rest of the filenames
;     loop:
;
;         // copy filename to array
;         length := filename_convert(&fcb, &array[array_length])
;
;         // update array and array length variables
;         array[array_length] := offset buffer + buffer_length
;         array_length := array_length + 1
;
;         // update buffer length
;         buffer_length := buffer_length + length + 1
;
;         // test if enough space in the array
;         if array_length = array_maxlen, then
;             return array_maxlen
;
;         // get the next file name
;         call f_snext
;         if no file then
;             break loop
;
;         // continue
;         continue loop
;
;     return array_length
;
	dseg $
read_filenames@array_offset	rw	1
read_filenames@array_length	rw	1
read_filenames@buffer		db    array_maxlen * (filename_size + 1)
read_filenames@buffer_length	rw	1
read_filenames@string_length	rw	1

	cseg $
	; initialize
	mov	read_filenames@array_offset, ax
	mov	read_filenames@array_length, 0
	mov	read_filenames@buffer_length, 0

	; get the first filename
	mov	cl, f_sfirst
	mov	dx, offset fcb
	call	ccpm

	; if no file, return 0
	cmp	al, 0ffh
	je	read_filenames@end

	; get the rest of the filenames
read_filenames@loop:

	; set si to the address of the filename
	; si := offset dma_buf + al * 32 + 1
	mov	si, offset dma_buf
	mov	cl, 5
	shl	al, cl
	add	si, ax
	inc	si

	; set di to the address of the destination
	; di := offset buffer + buffer_length
	mov	di, offset read_filenames@buffer

	; length := filename_convert(&fcb, &array[array_length])
	call	filename_convert	; copy filename to s_next
	mov	read_filenames@string_length, ax

	; array[array_length] := offset buffer + buffer_length
	mov	ax, offset read_filenames@buffer
	add	ax, read_filenames@buffer_length
	mov	bx, read_filenames@array_length
	shl	bx, 1
	add	bx, read_filenames@array_offset
	mov	[bx], ax

	; array_length := array_length + 1
	add	read_filenames@array_length, 2

	; buffer_length := buffer_length + length + 1
	inc	read_filenames@buffer_length

	; test if enough space in the array
	cmp	read_filenames@array_length, array_maxlen
	jnb	read_filenames@end

	; get the next file name
	mov	cl, f_snext
	mov	dx, offset fcb
	call	ccpm

	; if no file, then exit loop
	cmp	al, 0ffh
	je	read_filenames@end

	; otherwise, continue loop
	jmp	read_filenames@loop

read_filenames@end:
	mov	ax, read_filenames@array_len
	ret

exit:
	; exit
	mov	cl, p_termcpm
	call	ccpm

;;====
;;
;; Function: filename_convert
;;
;;     Converts 11-character filenames to <name><'.'><ext>.
;;     The result is null-terminated.  The length of the
;;     string is returned in ax.
;;
;; Parameters:
;;
;;     si - The address of the source string
;;     di - The address of the destination
;;
;; Returns:
;;
;;    ax - The length of the destination string (without the null-byte)
;;
;; Modified Registers:
;;
;;     si, di, ax, bx, cx
;;
;;====
;
; Register Usage:
;
;     si - pointer to the current character in the source string
;     di - pointer to the current character in the destination string
;     cx - counter
;     bx - saves the initial value of dx
;     ax - used for return of the length of the result string
;
; Pseudocode:
;
; bx = di
; cx = 8
; while cx > 0 do	// @name
;     [di++] = [si++]
;     cx--
;     if [si] == ' ' then
;         break
; end
; si += cx
; if [si] <> ' ' then	// @test_extension
;     cx = 3
;     [di] = '.'
;     di++
;     while cx > 0	// @extension
;         [di++] = [si++]
;         cx--
;         if [si] == ' 'then
;             break
;     end
; [di] = 0		// @end
; return di - bx
;
filename_convert:
	; copy the filename
	cld
	mov	cx, 8
	mov	bx, di		; save destination address

filename_convert@name:
	movsb
	dec	cx
	jz	filename_convert@test_extension
	cmp	byte ptr [si], ' '
	jne	filename_convert@name

	; adjust si to point to the extension
	add	si, cx

	; test whether there is an extension
filename_convert@test_extension:
	cmp	byte ptr [si], ' '
	je	filename_convert@end

	; copy the extension
	mov	byte ptr [di], '.'
	inc	di
	mov	cx, 3

filename_convert@extension:
	movsb
	dec	cx
	jz	filename_convert@end
	cmp	byte ptr [si], ' '
	jne	filename_convert@extension

filename_convert@end:
	; put null byte
	mov	[di], 0

	; return ax = length of the destination string
	sub	di, bx
	mov	ax, di
	ret


;;; External Imports ;;;

include bdos.def
include console.lib
include strings.lib
include system.lib


end

