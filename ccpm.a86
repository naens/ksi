;****h* ksi/ccpm
;  NAME
;    ccpm - implementation of the OS functions for CCP/M
;  DESCRIPTION
;    This module implements the functions defined in os.nfo file.
;    It can be linked with the usual DRI link86.cmd.
;******


public os_terminate
public os_print_char, os_new_line
extrn entry:near

c_write		equ	2

mc_absalloc	equ	56

p_term		equ	143
p_pdaddr	equ	156

ccpm		equ	224

tab		equ	9


dgroup	group	data, stack
cgroup	group	code

stack	sseg	para
		rw	400h
stack_base	rw	0


data	dseg
	org	100h
mem_top		rw	1


code	cseg
	org	0h
	mov	cx, ds
	mov	ss, cx
	lea	sp, stack_base
	mov	mem_top, sp
	jmp	entry


os_terminate:
	push	bp
	mov	bp, sp
	mov	cl, p_term
	mov	dl, 4[bp]
	int	ccpm

os_print_char:
	push	bp
	mov	bp, sp

	mov	cl, c_write
	mov	dl, 4[bp]
	int	ccpm

	pop	bp
	ret	2

os_new_line:
	mov	cl, c_write
	mov	dl, 0dh
	int	ccpm
	mov	cl, c_write
	mov	dl, 0ah
	int	ccpm


; This part of the module contains the functions needed for
; the initialization of the command line arguments.  The command tail
; is parsed, the program name is retrieved, and they are stored in
; the argv array, allocated by using the OS functions.
; Here is a quicvk overview of the functions defined.
; - program_name: is used to get the address of the program name as
;       well as its length;
; - tail_args: used to get the number of arguments in the command tail,
;       also returns the length and the address of the command tail;
; - ccpm_sys_alloc: used to allocate memory from the Operating System
;       at a specific address;
; - init_args: initializes argc and argv, so  that they can be returned
;       by the get_args function;
; - os_get_args: checks if the arguments are initialized, if not calls
;       the init_args function and returns argc and argv.
; All these functions are local, except os_get_args, that's why they
; are not prefixed by the 'os_' prefix.
; program_name: sets the segment and the offset pointing to the name
;     the program; also calculates its length.
program_name:
	; parameters:	8[bp]: pointer to the segment
	;		6[bp]: pointer to the offset
	;		4[bp]: pointer to the length
	push	bp
	mov	bp, sp

	mov	ch, p_pdaddr
	int	ccpm
	mov	bx, 8[bp]
	mov	[bx], es
	mov	bx, 6[bp]
	mov	[bx], ax

	; loop to calculate the length
	mov	si, ax
	mov	cx, 0
pn_loop:
	cmp	cx, 8
	je	pn_loop_end
	mov	al, es:[si]
	cmp	al, ' '
	je	pn_loop_end
	cmp	al, tab
	je	pn_loop_end
	inc	cx
	inc	si
	jmp	pn_loop
pn_loop_end:
	mov	bx, 4[bp]
	mov	[bx], cx

	pop	bp
	ret	6


; tail_args: returns the number of arguments in the command tail
; pseudocode
;  offset := 81h
;  length := [80h]
;  argc := 1
;  counter := length
;  is_word := false
;  p := 81h
;  while counter > 0 do:
;    if [p] = ' ' or [p] = TAB then
;      is_word := false
;    else if not is_word then
;      is_word := true
;      argc := argc + 1
;    end if
;    p := p + 1
;    counter := counter - 1
;  done
tail_args:
	; parameters:	8[bp]: address for the offset of the tail
	;		6[bp]: address for the length of the tail
	;		4[bp]: address for the argument count
	push	bp
	mov	bp, sp

	; set the offset and the length of the tail
	mov	bx, 8[bp]		; offset
	mov	ah, 0
	mov	al, 81h
	mov	[bx], ax
	mov	bx, 80h
	mov	al, [bx]
	mov	bx, 6[bp]		; length
	mov	bx, ax

	; loop to count the number of argumetns
	mov	dx, 1			; argument counter (0=name)
	mov	cl, al			; the length of the tail
	mov	ch, 0			; 0: space/tab, 1: word
	mov	si, 81h			; tail start
ta_loop:
	cmp	cl, 0
	je	ta_loop_end
	mov	al, [si]
	cmp	al, ' '
	je	ta_loop_space
	cmp	al, tab
	jne	ta_loop_not_space
ta_loop_space:
	mov	ch, 0
	jmp	ta_loop_end_if
ta_loop_not_space:
	cmp	ch, 0
	jne	ta_loop_end_if
	mov	ch, 1
	inc	dx
ta_loop_end_if:
	inc	si
	dec	cl
	jmp	ta_loop
ta_loop_end:

	mov	bx, 4[bp]
	mov	[bx], di

	pop	bp
	ret	6

; ccpm_sys_alloc: allocate an area with minimum the required number of
;     bytes and returns the starting address of this area.
	dseg
mcb		rw	3
	cseg
ccpm_sys_alloc:
	; parameters:	4[bp]: number of bytes
	; returns: the address of the start of the allocated area
	push	bp
	mov	bp, sp
	sub	sp, 2			; store paragraphs to allocate


	; convert the number of bytes to paragraphs and store in mcb
	mov	ax, 4[bp]
	add	ax, 15
	mov	cl, 4
	shr	ax, cl
	mov	mcb+3, ax
	mov	-2[bp], ax		; number of alloc para

	; store the address of the area in mcb
	mov	ax, mem_top
	mov	mcb, ax

	; allocate: system call
	mov	cl, mc_absalloc
	int	ccpm
	cmp	al, 0
	jne	csa_error

	; update mem_top
	mov	bx, -2[bp]		; allocated paragraphs
	mov	cl, 4
	shl	bx, cl
	mov	ax, mem_top
	add	mem_top, bx
	jmp	csa_end
csa_error:
	mov	ax, -1
csa_end:
	add	sp, 2
	pop	bp
	ret	2
; init_args: initialize argc and argv, global variables, so that they
;     can be returned by get_args.  The initial value of argc is 0,
;     which serves as an indicator that the function has not yet been
;     called.  This function does not accept any argument, but returns
;     a value of 0 on success and -1 on error (of size word).
	dseg
ia_pname_seg	rw	1
ia_pname_off	rw	1
ia_pname_len	rw	1
ia_tail_len	rw	1
argc		dw	0
argv		rw	1
ia_arg_buf	rw	1
ia_is_word	rb	1
	cseg
init_args:
	push	bp
	mov	bp, sp

	; get the name of the program into ia_pname_seg:ia_pname_off
	mov	ax, offset ia_pname_seg
	push	ax
	mov	ax, offset ia_pname_off
	push	ax
	mov	ax, offset ia_pname_len
	push	ax
	call	program_name

	; get the address and the length of the tail, as well as argc
	mov	ax, offset ia_tail_off
	push	ax
	mov	ax, offset ia_tail_len
	push	ax
	mov	ax, offset argc
	push	ax
	call	tail_args

	; allocate 2 * argc + ia_pname_len + ia_tail_len + 4 from ccpm
	mov	ax, argc
	shl	ax, 1
	add	ax, ia_pname_len
	add	ax, ia_tail_len
	add	ax, 4
	push	ax
	call	ccpm_sys_alloc
	cmp	ax, -1
	je	ia_error

	; ia_parg_buf = argv + 2 * (argc + 1)
	mov	argv, ax
	mov	bx, argc
	inc	bx
	shl	bx, 1
	add	ax, bx
	mov	ia_parg_buf, ax

	; copy the name of the program
	mov	es, ia_pname_seg
	mov	si, ia_pname_off
	mov	di, ia_parg_buf
	mov	cx, ia_pname_len
ia_pname_loop:
	cmp	cx, 0
	je	io_pname_loop_end
	mov	al, es:[si]
	mov	[di], al
	inc	si
	inc	di
	dec	cx
	jmp	ia_pname_loop
ia_pname_loop_end:
	mov	[di], 0

	inc	di
	mov	bx, argv
	mov	[bx], ia_parg_buf
	mov	iargv, 1
	mov	ia_is_word, 1
	mov	si, 0
ia_loop:
	cmp	si, tail_len
	je	ia_loop_end
	mov	al, tail_off[si]
	cmp	al, 0
	je	ia_loop_space
	cmp	al, tab
	jne	ia_loop_not_space
ia_loop_space:
	cmp	ia_is_word, 1
	jne	ia_loop_end_if
	mov	ia_is_word, 0
	mov	byte ptr [di], 0
	inc	di
	jmp	ia_loop_end_if
ia_loop_not_space:
	mov	[di], al
	cmp	ia_is_word, 0
	jne	ia_loop_word
	mov	ia_is_word, 1
	mov	[bx], si
	add	bx, 2
ia_loop_word:
	inc	di
ia_loop_end_if:
	inc	si
	jmp	ia_loop
ia_loop_end:

	cmp	is_word, 1
	jne	ia_not_word
	mov	byte ptr [di], 0

	mov	word ptr [bx], 0
	mov	ax, 0
ia_error:

	pop	bp
	ret
