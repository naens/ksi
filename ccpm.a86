;****h* ksi/ccpm
;
;  NAME
;    ccpm - Concurrent CP/M Module
;
;  DESCRIPTION
;    The Operating System module for Concurrent CP/M-86.  Contains
;    the functions needed so that the ksi library could communicate
;    with the OS.  These functions should only be called from the
;    library.
;
;    This module also provides the prologue and the epilogue of the
;    program.  So the program should be linked in a way that it
;    enters it first.
;
;    Every program should call the exit function of the sys library
;    when it's terminating.  This function calls the epilogue function
;    defined in this module, which is called osterm.
;
;******


public osterm, osexec, osprchr, osrdkey, osrdln

public osgetdate, ossetdate, osgettime, ossettime, osgetweekday


extrn entry:near


c_read		equ	1
c_write		equ	2
c_rawio		equ	6
c_writestr	equ	9
c_readstr	equ	10

f_open		equ	15
f_close		equ	16
f_sfirst	equ	17
f_snext		equ	18
f_delete	equ	19
f_read		equ	20
f_write		equ	21
f_make		equ	22

t_set		equ	104
t_get		equ	105
p_term		equ	143

ccpm		equ	224


dgroup	group	data, stack
cgroup	group	code

stack	sseg	word
		rw	1024
stack_base	rw	0


data	dseg
	org	100h


code	cseg

org	0h			; entry point of the program
	jmp	entry


;****f* os/osterm, osexec
;
;  NAME
;    osterm, osexec - process related functions
;
;  DESCRIPTION
;    The function osterm terminates the current program with the
;    status code specified.
;
;    osexec executes a program and returns to the caller.
;
;  RETURN VALUE
;    osterm doesn't return any value.
;    osexec returns the status code of the program that was ececuted.
;
;******

osterm:
	push	bp
	mov	bp, sp
	mov	cl, p_term
	mov	dl, 4[bp]
	int	ccpm

osterm_fail:			; shouldn't happen, spin just in case.
	jmp	osterm_fail

osexec:

;****f* os/osprchr, osrdkey, osrdln
;
;  NAME
;    osprchr, osrdkey, osrdln - functions for the console
;
;  SYNOPSIS
;    osprchr: procedure (b)
;    osrdkey: procedure (pstatus) word
;    osrdln: procedure (pstr, len) word
;
;  DESCRIPTION
;    The osprchr function takes one byte argument b and displays it
;    as ASCII character on the console.
;
;    The osrdkey function takes one address argument pstatus.  It
;    reads one key from the keyboard, stores the shift key status in
;    pstatus and returns the key in ax.  If the control key was
;    pressed together with the key, the key pressed is returned
;    as an uppercase character.  The ASCII code of the character
;    is in al, and ah contains the scan code.
;
;    The function osrdln takes the address of the string pstr, and the
;    maximum length len of the string len as arguments.  It reads one
;    line of input and stores maximum len bytes in the buffer at
;    address pstr.  The string is null-terminated.
;
;  RETURN VALUE
;    osprchr doesn't return a value.
;    osrdkey returns the ASCII code in al and the scan code in ah.
;    osrdln returns the length of the string read.
;
;******

osprchr:
	push	bp
	mov	bp, sp
	mov	cl, c_write
	mov	dl, 4[bp]
	int	ccpm
	pop	bp
	ret	2

osrdkey:
	push	bp
	mov	bp, sp

	mov	cl, c_rawio
	mov	dl, 0fdh
	int	ccpm
	cmp	al, 0
	je	osrdkey_l
	cmp	al, 32		; if ctrl-char, convert to uppercase
	jae	osrdkey_l
	add	al, 'A'-1
osrdkey_l:
	mov	word ptr 4[bp], 0

	pop	bp
	ret	2

osrdln:
	push	bp
	mov	bp, sp

	mov	cl, c_readstr
	mov	bx, 6[bp]
	mov	al, 4[bp]
	mov	[bx], al
	mov	dx, bx
	int	ccpm

	mov	bx, 6[bp]
	mov	cl, 1[bx]
	mov	dl, cl
	mov	dh, 0

osrdln_loop:
	cmp	cl, 0
	je	osrdln_end
	mov	al, 2[bx]
	mov	[bx], al
	dec	cl
	inc	bx
	jmp	osrdln_loop
osrdln_end:
	mov	byte ptr [bx], 0

	mov	cl, c_write
	mov	dl, 0dh
	int	ccpm

	mov	cl, c_write
	mov	dl, 0ah
	int	ccpm

	mov	ax, dx
	pop	bp
	ret	4


year_days:
	push	bp
	mov	bp, sp

	mov	ax, 4[bp]

	; if ax mod 4 <> 0 then return 365
	test	ax, 3
	mov	ax, 365
	jnz	year_days_end

	; (ax, dx) := (ax div 100, ax mod 100)
	mov	dx, 0
	mov	cx, 100
	div	cx

	; if year mod 100 <> 0 then goto 366	=(dx <> 0)
	cmp	dx, 0
	jnz	year_days_366

	; if year mod 400 <> 0 then return 365	=(ax and 3 <> 0)
	test	ax, 3
	mov	ax, 365
	jnz	year_days_end

year_days_366:
	mov	ax, 366

year_days_end:
	pop	bp
	ret	2


month_days:
	push	bp
	mov	bp, sp

	; for february: get number of days in year => 29 or 28
	cmp	word ptr 4[bp], 2
	jne	month_days_not2
	mov	ax, 6[bp]
	push	ax
	call	year_days
	sub	ax, 365-28
	jmp	month_days_end

month_days_not2:
	mov	ax, 4[bp]

	; if month > 7, decrease to get number of days with mod 2
	cmp	ax, 7
	jle	month_days_l7
	dec	ax
month_days_l7:

	; odd months or even >7 are 31 days, the rest (not 2) are 30
	test	ax, 1
	mov	ax, 30
	jz	month_days_30
	inc	ax
month_days_30:

month_days_end:
	pop	bp
	ret	4


; day_of_year (year, month, day) -> day of year

	dseg
doy_month	rw	1
doy_day		rw	1

	cseg
day_of_year:
	push	bp
	mov	bp, sp

	mov	ax, 4[bp]
	mov	doy_day, ax
	mov	doy_month, 1
doy_loop:
	mov	ax, doy_month
	cmp	ax, 6[bp]
	jae	doy_loop_end
	mov	ax, 8[bp]
	push	ax		; push year
	push	doy_month
	call	month_days
	add	doy_day, ax
	inc	doy_month
	jmp	doy_loop
doy_loop_end:

	mov	ax, doy_day
	pop	bp
	ret	6


; to_ccpm_days:	(year, month, day) -> number of days for CCP/M
	dseg
tcd_days	rw	1
tcd_year	rw	1

	cseg
to_ccpm_days:
	push	bp
	mov	bp, sp

	mov	ax, 8[bp]	; year
	push	ax
	mov	ax, 6[bp]	; month
	push	ax
	mov	ax, 4[bp]	; day
	push	ax
	call	day_of_year
	mov	tcd_days, ax

	mov	tcd_year, 1978
tcd_loop:
	mov	ax, tcd_year
	cmp	ax, 8[bp]
	jae	tcd_loop_end

	push	tcd_year
	call	year_days
	add	tcd_days, ax

	inc	tcd_year
	jmp	tcd_loop
tcd_loop_end:

	mov	ax, tcd_days
	pop	bp
	ret	6



; from_ccpm_days: days -> year, month, day
	dseg
fcd_year	rw	1
fcd_month	rw	1
fcd_day		rw	1

	cseg
from_ccpm_days:		; days(in), year(out), month(out), day(out)
	push	bp
	mov	bp, sp

	mov	fcd_year, 1978
	mov	ax, 10[bp]
	mov	fcd_day, ax
	push	fcd_year
	call	year_days
fcd_yloop:
	cmp	fcd_day, ax
	jle	fcd_yloop_end
	sub	fcd_day, ax
	inc	fcd_year
	push	fcd_year
	call	year_days
	jmp	fcd_yloop
fcd_yloop_end:

	mov	fcd_month, 1
	push	fcd_year
	push	fcd_month
	call	month_days
fcd_mloop:
	cmp	fcd_day, ax
	jle	fcd_mloop_end
	sub	fcd_day, ax
	inc	fcd_month
	push	fcd_year
	push	fcd_month
	call	month_days
	jmp	fcd_mloop
fcd_mloop_end:

	mov	bx, 4[bp]
	mov	cx, fcd_day
	mov	[bx], cx
	mov	bx, 6[bp]
	mov	cx, fcd_month
	mov	[bx], cx
	mov	bx, 8[bp]
	mov	cx, fcd_year
	mov	[bx], cx

	pop	bp
	ret	8


	dseg
time_of_day	rb	5

	cseg

; mini_double: convert a byte into bcd (which must fit the byte!)
mini_double:
	push	bp
	mov	bp, sp

	mov	al, 4[bp]
	mov	cl, 8
	mov	bl, 0
mini_double_loop:
	mov	bh, al
	and	bh, bl
	and	bh, 0Fh
	cmp	bh, 5
	jl	mini_double_label
	add	al, 3
mini_double_label:
	rol	al, 1
	shl	bl, 1
	inc	bl
	dec	cl
	cmp	cl, 0
	ja	mini_double_loop

	pop	bp
	ret	2

; mini_dabble: convert single-byte bcd to its binary value
mini_dabble:
	push	bp
	mov	bp, sp

	mov	al, 4[bp]
	mov	cl, 8
	mov	bl, 0FFh
mini_dabble_loop:
	ror	al, 1
	shr	bl, 1
	mov	bh, al
	and	bh, bl
	and	bh, 0Fh
	cmp	bh, 8
	jl	mini_dabble_label
	sub	al, 3
mini_dabble_label:
	dec	cl
	cmp	cl, 0
	ja	mini_dabble_loop

	pop	bp
	ret	2


osgetdate:
	push	bp
	mov	bp, sp

	mov	cl, t_get
	mov	dx, offset time_of_day
	int	ccpm

	mov	ax, word ptr time_of_day
	push	ax
	mov	ax, 8[bp]
	push	ax
	mov	ax, 6[bp]
	push	ax
	mov	ax, 4[bp]
	push	ax
	call	from_ccpm_days

	pop	bp
	ret	6


ossetdate:
	push	bp
	mov	bp, sp

	mov	cl, t_get
	mov	dx, offset time_of_day
	int	ccpm

	mov	ax, 8[bp]
	push	ax
	mov	ax, 6[bp]
	push	ax
	mov	ax, 4[bp]
	push	ax
	call	to_ccpm_days

	mov	cl, t_set
	mov	word ptr time_of_day, ax
	mov	dx, offset time_of_day
	int	ccpm
	
	pop	bp
	ret	6


osgettime:
	push	bp
	mov	bp, sp

	mov	cl, t_get
	mov	dx, offset time_of_day
	int	ccpm

	mov	al, time_of_day+2
	push	ax
	call	mini_dabble
	mov	bx, 8[bp]
	mov	[bx], ax

	mov	al, time_of_day+3
	push	ax
	call	mini_dabble
	mov	bx, 6[bp]
	mov	[bx], ax

	mov	al, time_of_day+4
	push	ax
	call	mini_dabble
	mov	bx, 4[bp]
	mov	[bx], ax

	pop	bp
	ret	6


ossettime:
	push	bp
	mov	bp, sp

	mov	cl, t_get
	mov	dx, offset time_of_day
	int	ccpm

	mov	al, 8[bp]
	push	ax
	call	mini_double
	mov	time_of_day+2, al

	mov	al, 6[bp]
	push	ax
	call	mini_double
	mov	time_of_day+3, al

	mov	al, 4[bp]
	push	ax
	call	mini_double
	mov	time_of_day+4, al

	mov	cl, t_set
	mov	dx, offset time_of_day
	int	ccpm

	pop	bp
	ret	6


osgetweekday:
	push	bp
	mov	bp, sp

	mov	cl, t_get
	mov	dx, offset time_of_day
	int	ccpm

	mov	ax, word ptr time_of_day
	add	ax, 5
	mov	dx, 0
	mov	cx, 7
	div	cx
	mov	ax, dx
	inc	ax

	pop	bp
	ret

end
